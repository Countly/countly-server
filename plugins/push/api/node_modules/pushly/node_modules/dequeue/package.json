{
  "name": "dequeue",
  "main": "./lib/index.js",
  "version": "1.0.5",
  "description": "A simple double ended queue datastructure",
  "keywords": [
    "datastructure",
    "queue",
    "double ended queue",
    "fifo",
    "FIFO",
    "linked list"
  ],
  "homepage": "https://github.com/lleo/node-dequeue",
  "repository": {
    "type": "git",
    "url": "https://github.com/lleo/node-dequeue"
  },
  "bugs": {
    "url": "https://github.com/lleo/node-dequeue/issues",
    "email": "lleoem@gmail.com"
  },
  "author": {
    "name": "LLeo",
    "email": "lleoem@gmail.com",
    "url": "http://lleo-blog.blogspot.com/"
  },
  "engines": {
    "node": "*"
  },
  "dependencies": {},
  "readme": "A Simple Double Ended Queue Datastructure\n=========================================\n\nDequeue is implemented as a doubly linked circular list with a titular head\nnode. By \"titular head node\", I mean an empty node to designate the beginning\nand end of the circularly linked list. I first saw this construction in the\nlinux kernel source and it seem simple and elegant. I added the `.length`\nproperty to use it like I was using an Array.\n\nI was using a javascript Array as a FIFO. Somewhere between 100,000 and\n200,000 entries the program performance went to hell (dev host is a MBP\nw/8GB RAM). 15 minutes later, I implemented a simple dequeue and my FIFO\nscales up to millions of entries.\n\nIt is a drop-in replacement for javascript-arrays-as-fifo.\n\n## Example: Dequeue as a replacement for an Array as a FIFO\n\n    var Dequeue = require('dequeue')\n    \n    //var fifo = []\n    var fifo = new Dequeue()\n    \n    fifo.length === 0 //=> true\n    \n    fifo.push(d1)\n    fifo.length === 1 //=> true\n    \n    fifo.unshift(d2)\n    \n    fifo.pop() === d1 //=> true\n    \n    fifo.push(d3)\n    \n    fifo.shift() === d2 //=> true\n    \n    fifo.length === 1 //=> true; only d3 is in the dequeue\n    \n## API\n\n### `deque = new Dequeue()`\n\n### `deque.push(value)`\nPush a value on the end.\n\n### `value = deque.pop()`\nRemove a value off the end.\n\n### `deque.unshift(value)`\nPush a value on the beginning.\n\n### `value = deque.shift()`\nRemove a value off the beginning.\n\n### `value = deque.last()`\nExamine the value of the end without removing it.\n\n### `value = deque.first()`\nExamine the value of the beginning without removing it.\n\n### `deque.empty()`\nRemove all entries. This is NOT a test for an empty dequeue; use `deque.length`\nfor that.\n\n## Future Development\nSomething this simple does not really need a roadmap. However, I am thinking\nof adding APIs to facilitate walking the Linked List via an iterator. It will\nbe simple and fully backward compatible.\n\n## About the Code\n\nI was convinced by [a blog posting](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding) [by Issac Z. Schlueter](http://blog.izs.me/) that I don't need\nsemicolons. So I don't use them.\n",
  "readmeFilename": "README.md",
  "_id": "dequeue@1.0.5",
  "_shasum": "10f1cef07e3234b21dcb38f4bfa2d66034ab67c7",
  "_from": "dequeue@",
  "_resolved": "https://registry.npmjs.org/dequeue/-/dequeue-1.0.5.tgz"
}
