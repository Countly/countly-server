- op: replace
  path: /data/config.alloy
  value: |
    // ===== Log Collection (Kubernetes Pods) =====
    // Replaces Promtail functionality
    discovery.kubernetes "pods" {
      role = "pod"
      namespaces {
        names = ["countly", "countly-observability"]
      }
    }
    
    discovery.relabel "pods" {
      targets = discovery.kubernetes.pods.targets
      
      rule {
        source_labels = ["__meta_kubernetes_pod_controller_name"]
        regex         = "([0-9a-z-.]+?)(-[0-9a-f]{8,10})?"
        target_label  = "__tmp_controller_name"
      }
      
      rule {
        source_labels = ["__meta_kubernetes_pod_label_app", "__meta_kubernetes_pod_label_component", "__tmp_controller_name", "__meta_kubernetes_pod_name"]
        regex         = "^;*([^;]+)(;.*)?$"
        target_label  = "app"
      }
      
      rule {
        source_labels = ["__meta_kubernetes_pod_label_app", "__meta_kubernetes_pod_label_component", "__tmp_controller_name", "__meta_kubernetes_pod_name"]
        regex         = "^([^;]+);*.*$"
        target_label  = "component"
      }
      
      rule {
        source_labels = ["__meta_kubernetes_pod_node_name"]
        target_label  = "node_name"
      }
      
      rule {
        source_labels = ["__meta_kubernetes_namespace"]
        target_label  = "namespace"
      }
      
      rule {
        source_labels = ["namespace", "app"]
        separator     = "/"
        target_label  = "job"
      }
      
      rule {
        source_labels = ["__meta_kubernetes_pod_name"]
        target_label  = "pod"
      }
      
      rule {
        source_labels = ["__meta_kubernetes_pod_container_name"]
        target_label  = "container"
      }
      
      rule {
        source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
        separator     = "/"
        target_label  = "__path__"
        replacement   = "/var/log/pods/*$1/*.log"
      }
    }
    
    local.file_match "pods" {
      path_targets = discovery.relabel.pods.output
    }
    
    // ===== Remote Write Components (defined first) =====
    loki.write "remote" {
      endpoint {
        url = env("LOKI_ENDPOINT")
        basic_auth {
          username = env("LOKI_USERNAME")
          password = env("LOKI_BEARER_TOKEN")
        }
      }
      external_labels = {
        cluster = "countly-production",
      }
    }
    
    loki.write "otlp" {
      endpoint {
        url = env("LOKI_ENDPOINT")
        basic_auth {
          username = env("LOKI_USERNAME")
          password = env("LOKI_BEARER_TOKEN")
        }
      }
      external_labels = {
        source = "otlp",
        cluster = "countly-production",
      }
    }
    
    loki.process "pods" {
      forward_to = [loki.write.remote.receiver]
      
      stage.json {
        expressions = {
          level     = "level",
          msg       = "msg",
          span_id   = "span.id",
          timestamp = "time",
          trace_id  = "trace.id",
        }
      }
      
      stage.labels {
        values = {
          level = null,
        }
      }
      
      stage.timestamp {
        source = "timestamp"
        format = "RFC3339"
      }
    }
    
    loki.source.file "pods" {
      targets               = local.file_match.pods.targets
      forward_to            = [loki.process.pods.receiver]
      legacy_positions_file = "/tmp/alloy/positions.yaml"
    }
    
    // ===== Prometheus Remote Write =====
    prometheus.remote_write "remote" {
      endpoint {
        url = env("PROMETHEUS_ENDPOINT")
        basic_auth {
          username = env("PROMETHEUS_USERNAME")
          password = env("PROMETHEUS_BEARER_TOKEN")
        }
      }
      external_labels = {
        cluster = "countly-production",
      }
    }
    
    // ===== OTLP Components Pipeline (ordered by dependency) =====
    
    // Step 1: Define Auth Components (no dependencies)
    otelcol.auth.basic "tempo" {
      username = env("TEMPO_USERNAME")
      password = env("TEMPO_AUTH_HEADER")
    }
    
    // Step 2: Define Exporters (depend on auth components where needed)
    otelcol.exporter.prometheus "remote" {
      forward_to = [prometheus.remote_write.remote.receiver]
    }
    
    otelcol.exporter.loki "remote" {
      forward_to = [loki.write.otlp.receiver]
    }
    
    otelcol.exporter.otlp "tempo" {
      client {
        endpoint = env("TEMPO_ENDPOINT")
        auth = otelcol.auth.basic.tempo.handler
      }
    }
    
    otelcol.exporter.otlphttp "pyroscope" {
      client {
        endpoint = env("PYROSCOPE_ENDPOINT")
        headers = {
          "Authorization" = "Bearer " + env("PYROSCOPE_AUTH_HEADER"),
        }
      }
    }
    
    // Step 3: Memory Limiter (depends on exporters)
    otelcol.processor.memory_limiter "default" {
      check_interval = "5s"
      limit_mib = 2048
      spike_limit_mib = 512
      
      output {
        metrics = [otelcol.exporter.prometheus.remote.input]
        logs    = [otelcol.exporter.loki.remote.input]
        traces  = [otelcol.exporter.otlp.tempo.input]
        profiles = [otelcol.exporter.otlphttp.pyroscope.input]
      }
    }
    
    // Step 4: Batch Processors (depend on memory limiter)
    otelcol.processor.batch "default" {
      timeout = "5s"
      send_batch_size = 1024
      
      output {
        metrics = [otelcol.processor.memory_limiter.default.input]
        logs    = [otelcol.processor.memory_limiter.default.input]
        traces  = [otelcol.processor.memory_limiter.default.input]
      }
    }
    
    otelcol.processor.batch "profiles" {
      timeout = "5s"
      send_batch_size = 1024
      
      output {
        profiles = [otelcol.processor.memory_limiter.default.input]
      }
    }
    
    // Step 5: Resource Processor (depends on batch processors)
    otelcol.processor.resource "default" {
      attributes {
        key = "service.namespace"
        value = "countly"
        action = "upsert"
      }
      
      attributes {
        key = "deployment.environment"
        value = "production"
        action = "insert"
      }
      
      attributes {
        key = "cluster"
        value = "countly-production"
        action = "insert"
      }
      
      output {
        metrics = [otelcol.processor.batch.default.input]
        logs    = [otelcol.processor.batch.default.input]
        traces  = [otelcol.processor.batch.default.input]
        profiles = [otelcol.processor.batch.profiles.input]
      }
    }
    
    // Step 6: K8s Attributes Processor (depends on resource processor)
    otelcol.processor.k8sattributes "default" {
      extract {
        metadata = [
          "k8s.pod.name",
          "k8s.pod.uid",
          "k8s.deployment.name",
          "k8s.namespace.name",
          "k8s.node.name",
          "k8s.pod.start_time",
          "k8s.replicaset.name",
          "k8s.replicaset.uid",
          "k8s.daemonset.name",
          "k8s.daemonset.uid",
          "k8s.job.name",
          "k8s.job.uid",
          "k8s.statefulset.name",
          "k8s.statefulset.uid",
          "k8s.container.name",
          "k8s.cronjob.name",
        ]
        
        annotations = [{
          tag_name = "component",
          key      = "app.kubernetes.io/component",
          from     = "pod",
        }]
        
        labels = [{
          tag_name = "app_name",
          key      = "app",
          from     = "pod",
        }, {
          tag_name = "component",
          key      = "component",
          from     = "pod",
        }]
      }
      
      pod_association {
        source {
          from = "resource_attribute"
          name = "k8s.pod.ip"
        }
      }
      
      pod_association {
        source {
          from = "resource_attribute"
          name = "k8s.pod.uid"
        }
      }
      
      pod_association {
        source {
          from = "connection"
        }
      }
      
      output {
        metrics = [otelcol.processor.resource.default.input]
        logs    = [otelcol.processor.resource.default.input]
        traces  = [otelcol.processor.resource.default.input]
        profiles = [otelcol.processor.resource.default.input]
      }
    }
    
    // Step 7: OTLP Receiver (entry point, depends on k8s attributes processor)
    otelcol.receiver.otlp "default" {
      grpc {
        endpoint = "0.0.0.0:4317"
      }
      
      http {
        endpoint = "0.0.0.0:4318"
      }
      
      output {
        metrics = [otelcol.processor.k8sattributes.default.input]
        logs    = [otelcol.processor.k8sattributes.default.input]
        traces  = [otelcol.processor.k8sattributes.default.input]
        profiles = [otelcol.processor.k8sattributes.default.input]
      }
    }
    
    // ===== Prometheus Self Monitoring =====
    prometheus.exporter.self "alloy" {
      include_exporter_metrics = false
    }
    
    prometheus.scrape "alloy" {
      targets    = prometheus.exporter.self.alloy.targets
      forward_to = [prometheus.remote_write.remote.receiver]
      job_name   = "alloy"
      scrape_interval = "10s"
    }