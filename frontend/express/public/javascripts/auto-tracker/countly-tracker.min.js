/* eslint-disable */
/*!
 * Countly Web Tracker v1.0.0
 * (c) 2025 Countly
 * Released under the MIT License.
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.CountlyTracker = {}));
})(this, (function (exports) { 'use strict';

    /**
     * Utilities for working with Countly SDK
     */
    class CountlyUtils {
        /**
         * Generate a unique device ID
         */
        static generateDeviceId() {
            const timestamp = Date.now().toString(36);
            const random = Math.random().toString(36).substr(2);
            return `web_${timestamp}_${random}`;
        }
        /**
         * Get or create device ID from localStorage
         */
        static getDeviceId() {
            const stored = localStorage.getItem('countly_device_id');
            if (stored) {
                return stored;
            }
            const deviceId = this.generateDeviceId();
            localStorage.setItem('countly_device_id', deviceId);
            return deviceId;
        }
        /**
         * Get current timestamp in seconds
         */
        static getTimestamp() {
            return Math.floor(Date.now() / 1000);
        }
        /**
         * Sanitize string for Countly
         */
        static sanitizeString(str) {
            return str.replace(/[^\w\s-_.]/g, '').trim().substring(0, 255);
        }
        /**
         * Extract element attributes safely
         */
        static getElementAttributes(element, captureAttributes = []) {
            const attributes = {};
            // Always capture basic attributes
            const basicAttrs = ['id', 'class', 'name', 'type', 'value', 'placeholder'];
            const allAttrs = [...basicAttrs, ...captureAttributes];
            allAttrs.forEach(attr => {
                const value = element.getAttribute(attr);
                if (value && value.length > 0) {
                    attributes[attr] = this.sanitizeString(value);
                }
            });
            return attributes;
        }
        /**
         * Get element text content safely
         */
        static getElementText(element) {
            const text = element.textContent || '';
            return this.sanitizeString(text).substring(0, 100);
        }
        /**
         * Get element position in viewport
         */
        static getElementPosition(element) {
            const rect = element.getBoundingClientRect();
            return {
                x: Math.round(rect.left + rect.width / 2),
                y: Math.round(rect.top + rect.height / 2)
            };
        }
        /**
         * Check if element should be ignored
         */
        static shouldIgnoreElement(element, ignoreSelectors = []) {
            // Check if element is valid and has tagName
            if (!element || !element.tagName) {
                return true; // Ignore invalid elements
            }
            // First check by tag name directly for performance
            const tagName = element.tagName.toLowerCase();
            if (ignoreSelectors.includes(tagName)) {
                return true;
            }
            // Then check other selectors
            for (const selector of ignoreSelectors) {
                // Skip simple tag names as we already checked them
                if (selector === tagName) {
                    continue;
                }
                try {
                    if (element.matches && element.matches(selector)) {
                        return true;
                    }
                }
                catch (e) {
                    // Silently continue for invalid selectors in production
                    if (console && console.warn) {
                        console.warn('Countly: Invalid selector:', selector, e);
                    }
                }
            }
            return false;
        }
        /**
         * Generate a unique HTML path for an element
         */
        static getElementPath(element) {
            const path = [];
            let current = element;
            while (current && current.nodeType === Node.ELEMENT_NODE) {
                let selector = current.tagName.toLowerCase();
                // Add ID if available
                if (current.id) {
                    selector += `#${current.id}`;
                    path.unshift(selector);
                    break; // ID is unique, we can stop here
                }
                // Add class if available
                if (current.className && typeof current.className === 'string') {
                    const classes = current.className.trim().split(/\s+/).filter(cls => cls && !cls.startsWith('countly-') // Exclude our own classes
                    );
                    if (classes.length > 0) {
                        selector += `.${classes.join('.')}`;
                    }
                }
                // Add nth-child if there are siblings
                const parent = current.parentElement;
                if (parent && parent.children && current) {
                    try {
                        const siblings = Array.from(parent.children).filter((child) => child.tagName === current.tagName);
                        if (siblings.length > 1) {
                            const index = siblings.indexOf(current) + 1;
                            if (index > 0) {
                                selector += `:nth-child(${index})`;
                            }
                        }
                    }
                    catch (e) {
                        // Silently continue if there's an issue with sibling detection
                    }
                }
                path.unshift(selector);
                current = parent;
            }
            return path.join(' > ');
        }
        /**
         * Generate a consistent ID for an element based on its HTML path
         */
        static generateElementId(element) {
            const path = this.getElementPath(element);
            // Create a hash of the path for a shorter, consistent ID
            let hash = 0;
            for (let i = 0; i < path.length; i++) {
                const char = path.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            const hashStr = Math.abs(hash).toString(36);
            const tagName = element.tagName.toLowerCase();
            return `${tagName}_${hashStr}`;
        }
        /**
         * Get comprehensive element information including parent details
         */
        static getElementInfo(element, captureAttributes = []) {
            const parent = element.parentElement;
            const attributes = this.getElementAttributes(element, captureAttributes);
            // Use existing ID or generate one based on HTML path
            const elementId = element.id || this.generateElementId(element);
            const info = {
                element_id: elementId,
                element_tag: element.tagName.toLowerCase(),
                element_path: this.getElementPath(element),
                attributes
            };
            // Add classes if present
            if (element.className && typeof element.className === 'string') {
                const classes = element.className.trim();
                if (classes) {
                    info.element_classes = classes;
                }
            }
            // Add parent information if available
            if (parent) {
                info.parent_tag = parent.tagName.toLowerCase();
                if (parent.id) {
                    info.parent_id = parent.id;
                }
                if (parent.className && typeof parent.className === 'string') {
                    const parentClasses = parent.className.trim();
                    if (parentClasses) {
                        info.parent_classes = parentClasses;
                    }
                }
            }
            return info;
        }
        /**
         * Get current page information
         */
        static getCurrentPage() {
            return {
                url: window.location.href,
                title: document.title,
                referrer: document.referrer || undefined,
                loadTime: performance.timing ?
                    performance.timing.loadEventEnd - performance.timing.navigationStart :
                    undefined
            };
        }
        /**
         * Build Countly request URL
         */
        static buildRequestUrl(baseUrl, appKey, deviceId, events) {
            const params = new URLSearchParams({
                app_key: appKey,
                device_id: deviceId,
                events: JSON.stringify(events),
                timestamp: this.getTimestamp().toString(),
                sdk_name: 'web-tracker',
                sdk_version: '1.0.0'
            });
            return `${baseUrl}/i?${params.toString()}`;
        }
        /**
         * Build Countly request data for POST
         */
        static buildRequestData(appKey, deviceId, events, appVersion) {
            const requestData = {
                app_key: appKey,
                device_id: deviceId,
                events: JSON.stringify(events),
                timestamp: this.getTimestamp().toString(),
                sdk_name: 'web-tracker',
                sdk_version: '1.0.0'
            };
            // Add app_version if provided
            if (appVersion) {
                requestData.app_version = appVersion;
            }
            return requestData;
        }
        /**
         * Debounce function
         */
        static debounce(func, wait) {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = window.setTimeout(() => func(...args), wait);
            };
        }
        /**
         * Find label associated with an input element
         */
        static getInputLabel(input) {
            // Method 1: Label with 'for' attribute pointing to input ID
            if (input.id) {
                const labelByFor = document.querySelector(`label[for="${input.id}"]`);
                if (labelByFor) {
                    return {
                        text: this.sanitizeString(labelByFor.textContent || '').trim(),
                        id: labelByFor.id || undefined,
                        association: 'for-attribute'
                    };
                }
            }
            // Method 2: Input wrapped inside a label element
            const wrappingLabel = input.closest('label');
            if (wrappingLabel) {
                // Get text content but exclude the input's own text
                const labelText = wrappingLabel.textContent || '';
                const inputText = input.value || input.placeholder || '';
                const cleanedText = labelText.replace(inputText, '').trim();
                return {
                    text: this.sanitizeString(cleanedText),
                    id: wrappingLabel.id || undefined,
                    association: 'wrapping-label'
                };
            }
            // Method 3: Look for label as a sibling element (common pattern)
            const parent = input.parentElement;
            if (parent) {
                // Look for label siblings
                const siblingLabel = parent.querySelector('label');
                if (siblingLabel && !siblingLabel.getAttribute('for')) {
                    return {
                        text: this.sanitizeString(siblingLabel.textContent || '').trim(),
                        id: siblingLabel.id || undefined,
                        association: 'sibling-label'
                    };
                }
            }
            // Method 4: Look for aria-label or aria-labelledby
            const ariaLabel = input.getAttribute('aria-label');
            if (ariaLabel) {
                return {
                    text: this.sanitizeString(ariaLabel).trim(),
                    association: 'aria-label'
                };
            }
            const ariaLabelledBy = input.getAttribute('aria-labelledby');
            if (ariaLabelledBy) {
                const labelElement = document.getElementById(ariaLabelledBy);
                if (labelElement) {
                    return {
                        text: this.sanitizeString(labelElement.textContent || '').trim(),
                        id: labelElement.id,
                        association: 'aria-labelledby'
                    };
                }
            }
            // Method 5: Look for common patterns like preceding text nodes or elements
            const previousSibling = input.previousElementSibling;
            if (previousSibling &&
                ['span', 'div', 'p', 'strong', 'b', 'em', 'i'].includes(previousSibling.tagName.toLowerCase())) {
                const text = previousSibling.textContent || '';
                if (text.trim().length > 0 && text.trim().length < 100) { // Reasonable label length
                    return {
                        text: this.sanitizeString(text).trim(),
                        association: 'preceding-element'
                    };
                }
            }
            // Method 6: Look for title attribute as fallback
            const title = input.getAttribute('title');
            if (title) {
                return {
                    text: this.sanitizeString(title).trim(),
                    association: 'title-attribute'
                };
            }
            return {};
        }
        /**
         * Throttle function
         */
        static throttle(func, limit) {
            let inThrottle;
            return (...args) => {
                if (!inThrottle) {
                    func(...args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }
        /**
         * Get comprehensive page and viewport context
         */
        static getPageContext() {
            const context = {};
            try {
                // Screen dimensions
                if (typeof window !== 'undefined' && window.screen) {
                    context.screen_width = window.screen.width;
                    context.screen_height = window.screen.height;
                    context.screen_orientation = window.screen.orientation?.type || 'unknown';
                }
                // Viewport dimensions
                if (typeof window !== 'undefined') {
                    context.viewport_width = window.innerWidth || document.documentElement.clientWidth;
                    context.viewport_height = window.innerHeight || document.documentElement.clientHeight;
                }
                // Page dimensions
                if (typeof document !== 'undefined') {
                    const body = document.body;
                    const documentElement = document.documentElement;
                    if (body && documentElement) {
                        // Get the full page dimensions
                        context.page_width = Math.max(body.scrollWidth, body.offsetWidth, documentElement.clientWidth, documentElement.scrollWidth, documentElement.offsetWidth);
                        context.page_height = Math.max(body.scrollHeight, body.offsetHeight, documentElement.clientHeight, documentElement.scrollHeight, documentElement.offsetHeight);
                    }
                }
                // Scroll position
                if (typeof window !== 'undefined') {
                    context.scroll_x = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
                    context.scroll_y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
                }
                // Device pixel ratio
                if (typeof window !== 'undefined' && window.devicePixelRatio) {
                    context.device_pixel_ratio = Math.round(window.devicePixelRatio * 100) / 100; // Round to 2 decimal places
                }
                // Page URL and title
                if (typeof window !== 'undefined' && window.location) {
                    context.page_url = window.location.href;
                    context.page_pathname = window.location.pathname;
                    context.page_hash = window.location.hash || '';
                    context.page_search = window.location.search || '';
                }
                if (typeof document !== 'undefined') {
                    context.page_title = document.title || '';
                }
                // User agent info (simplified)
                if (typeof navigator !== 'undefined') {
                    const userAgent = navigator.userAgent;
                    context.is_mobile = /Mobile|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent) ? 1 : 0;
                    context.is_tablet = /iPad|Android(?!.*Mobile)/i.test(userAgent) ? 1 : 0;
                }
                // Timezone
                if (typeof Intl !== 'undefined' && Intl.DateTimeFormat) {
                    try {
                        context.timezone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'unknown';
                    }
                    catch (e) {
                        context.timezone = 'unknown';
                    }
                }
            }
            catch (error) {
                // Silently handle errors in case of restricted environments
                console.warn('Countly: Error getting page context', error);
            }
            return context;
        }
    }

    /**
     * Manages event queue and batch sending to Countly
     */
    class EventQueue {
        constructor(config) {
            this.events = [];
            this.flushTimer = null;
            this.MAX_QUEUE_SIZE = 100;
            this.FLUSH_INTERVAL = 30000; // 30 seconds
            this.config = config;
            this.startAutoFlush();
        }
        /**
         * Add event to queue
         */
        addEvent(event) {
            // Set default values
            const processedEvent = {
                count: 1,
                timestamp: CountlyUtils.getTimestamp(),
                ...event
            };
            // Initialize segmentation if not present
            processedEvent.segmentation = processedEvent.segmentation || {};
            // Add app_version to segmentation if provided and not already present
            if (this.config.app_version && this.config.app_version.trim() !== '') {
                if (!processedEvent.segmentation.app_version) {
                    processedEvent.segmentation.app_version = this.config.app_version;
                }
            }
            // Add page context to all events (viewport, screen, page size, scroll)
            const pageContext = CountlyUtils.getPageContext();
            Object.entries(pageContext).forEach(([key, value]) => {
                // Only add if not already present in the event's segmentation
                if (!(key in processedEvent.segmentation)) {
                    processedEvent.segmentation[key] = value;
                }
            });
            this.events.push(processedEvent);
            if (this.config.debug) {
                console.log('Countly: Event added to queue', processedEvent);
            }
            // Auto flush if queue is getting full
            if (this.events.length >= this.MAX_QUEUE_SIZE) {
                this.flush();
            }
        }
        /**
         * Flush all events to Countly
         */
        async flush() {
            if (this.events.length === 0) {
                return;
            }
            const eventsToSend = [...this.events];
            this.events = [];
            try {
                const url = `${this.config.url}/i`;
                const requestData = CountlyUtils.buildRequestData(this.config.app_key, this.config.device_id, eventsToSend, this.config.app_version);
                if (this.config.debug) {
                    console.log('Countly: Sending events', eventsToSend);
                    console.log('Countly: Request URL', url);
                    console.log('Countly: Request data', requestData);
                }
                // Use sendBeacon if available for better reliability
                if (navigator.sendBeacon) {
                    const formData = new FormData();
                    Object.entries(requestData).forEach(([key, value]) => {
                        formData.append(key, value);
                    });
                    const success = navigator.sendBeacon(url, formData);
                    if (!success && this.config.debug) {
                        console.warn('Countly: sendBeacon failed, falling back to fetch');
                        await this.sendWithFetch(url, requestData);
                    }
                }
                else {
                    await this.sendWithFetch(url, requestData);
                }
            }
            catch (error) {
                if (this.config.debug) {
                    console.error('Countly: Failed to send events', error);
                }
                // Put events back in queue for retry
                this.events.unshift(...eventsToSend);
            }
        }
        /**
         * Send events using fetch API
         */
        async sendWithFetch(url, requestData) {
            const formData = new FormData();
            Object.entries(requestData).forEach(([key, value]) => {
                formData.append(key, value);
            });
            const response = await fetch(url, {
                method: 'POST',
                mode: 'cors',
                credentials: 'omit',
                body: formData
            });
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
        }
        /**
         * Start automatic flush timer
         */
        startAutoFlush() {
            this.flushTimer = window.setInterval(() => {
                this.flush();
            }, this.FLUSH_INTERVAL);
        }
        /**
         * Stop automatic flush timer
         */
        stopAutoFlush() {
            if (this.flushTimer) {
                clearInterval(this.flushTimer);
                this.flushTimer = null;
            }
        }
        /**
         * Get current queue size
         */
        getQueueSize() {
            return this.events.length;
        }
        /**
         * Clear all events from queue
         */
        clear() {
            this.events = [];
        }
        /**
         * Flush on page unload
         */
        setupUnloadListener() {
            window.addEventListener('beforeunload', () => {
                this.flush();
            });
            window.addEventListener('pagehide', () => {
                this.flush();
            });
            // For single page applications
            window.addEventListener('popstate', () => {
                this.flush();
            });
        }
    }

    /**
     * Automatic event tracking for web interactions
     */
    class AutoTracker {
        constructor(eventQueue, config) {
            this.clickListener = null;
            this.submitListener = null;
            this.scrollListener = null;
            this.popstateListener = null;
            this.focusListener = null;
            this.blurListener = null;
            this.inputListener = null;
            this.changeListener = null;
            // New event listeners for comprehensive tracking
            this.mouseenterListener = null;
            this.mouseleaveListener = null;
            this.contextmenuListener = null;
            this.dblclickListener = null;
            this.keydownListener = null;
            this.visibilityListener = null;
            this.beforeunloadListener = null;
            this.resizeListener = null;
            this.selectionListener = null;
            this.onlineListener = null;
            this.offlineListener = null;
            this.orientationListener = null;
            this.scrollThresholds = [25, 50, 75, 90, 100];
            this.reachedScrollThresholds = new Set();
            this.currentPage = '';
            this.focusStartTimes = new Map();
            this.inputInteractionTimes = new Map();
            this.mediaElements = new Set();
            this.hoverStartTimes = new Map();
            this.visibilityStartTime = Date.now();
            this.totalVisibleTime = 0;
            this.eventQueue = eventQueue;
            this.config = config;
            this.currentPage = window.location.href;
        }
        /**
         * Start automatic tracking based on configuration
         */
        start() {
            if (this.config.auto_track_views) {
                this.trackPageView();
                this.setupPageViewTracking();
            }
            if (this.config.auto_track_clicks) {
                this.setupClickTracking();
            }
            if (this.config.auto_track_forms) {
                this.setupFormTracking();
            }
            if (this.config.auto_track_scroll) {
                this.setupScrollTracking();
            }
            if (this.config.auto_track_focus) {
                this.setupFocusTracking();
            }
            if (this.config.auto_track_inputs) {
                this.setupInputTracking();
            }
            if (this.config.auto_track_media) {
                this.setupMediaTracking();
            }
            if (this.config.auto_track_mouse) {
                this.setupMouseTracking();
            }
            if (this.config.auto_track_keyboard) {
                this.setupKeyboardTracking();
            }
            if (this.config.auto_track_visibility) {
                this.setupVisibilityTracking();
            }
            if (this.config.auto_track_window) {
                this.setupWindowTracking();
            }
            if (this.config.auto_track_selection) {
                this.setupSelectionTracking();
            }
            if (this.config.auto_track_performance) {
                this.setupPerformanceTracking();
            }
        }
        /**
         * Stop all automatic tracking
         */
        stop() {
            if (this.clickListener) {
                document.removeEventListener('click', this.clickListener, true);
                this.clickListener = null;
            }
            if (this.submitListener) {
                document.removeEventListener('submit', this.submitListener, true);
                this.submitListener = null;
            }
            if (this.scrollListener) {
                window.removeEventListener('scroll', this.scrollListener);
                this.scrollListener = null;
            }
            if (this.popstateListener) {
                window.removeEventListener('popstate', this.popstateListener);
                this.popstateListener = null;
            }
            if (this.focusListener) {
                document.removeEventListener('focusin', this.focusListener, true);
                this.focusListener = null;
            }
            if (this.blurListener) {
                document.removeEventListener('focusout', this.blurListener, true);
                this.blurListener = null;
            }
            if (this.inputListener) {
                document.removeEventListener('input', this.inputListener, true);
                this.inputListener = null;
            }
            if (this.changeListener) {
                document.removeEventListener('change', this.changeListener, true);
                this.changeListener = null;
            }
            // Clean up new event listeners
            if (this.mouseenterListener) {
                document.removeEventListener('mouseenter', this.mouseenterListener, true);
                this.mouseenterListener = null;
            }
            if (this.mouseleaveListener) {
                document.removeEventListener('mouseleave', this.mouseleaveListener, true);
                this.mouseleaveListener = null;
            }
            if (this.contextmenuListener) {
                document.removeEventListener('contextmenu', this.contextmenuListener, true);
                this.contextmenuListener = null;
            }
            if (this.dblclickListener) {
                document.removeEventListener('dblclick', this.dblclickListener, true);
                this.dblclickListener = null;
            }
            if (this.keydownListener) {
                document.removeEventListener('keydown', this.keydownListener, true);
                this.keydownListener = null;
            }
            if (this.visibilityListener) {
                document.removeEventListener('visibilitychange', this.visibilityListener);
                this.visibilityListener = null;
            }
            if (this.beforeunloadListener) {
                window.removeEventListener('beforeunload', this.beforeunloadListener);
                this.beforeunloadListener = null;
            }
            if (this.resizeListener) {
                window.removeEventListener('resize', this.resizeListener);
                this.resizeListener = null;
            }
            if (this.selectionListener) {
                document.removeEventListener('mouseup', this.selectionListener, true);
                this.selectionListener = null;
            }
            if (this.onlineListener) {
                window.removeEventListener('online', this.onlineListener);
                this.onlineListener = null;
            }
            if (this.offlineListener) {
                window.removeEventListener('offline', this.offlineListener);
                this.offlineListener = null;
            }
            if (this.orientationListener) {
                window.removeEventListener('orientationchange', this.orientationListener);
                this.orientationListener = null;
            }
            // Clean up media event listeners
            this.mediaElements.forEach(element => {
                this.removeMediaListeners(element);
            });
            this.mediaElements.clear();
        }
        /**
         * Track current page view
         */
        trackPageView() {
            const pageInfo = CountlyUtils.getCurrentPage();
            const event = {
                key: 'page_view',
                segmentation: {
                    url: pageInfo.url,
                    title: pageInfo.title,
                    referrer: pageInfo.referrer || '',
                    load_time: pageInfo.loadTime || 0
                }
            };
            this.eventQueue.addEvent(event);
            if (this.config.debug) {
                console.log('Countly: Page view tracked', pageInfo);
            }
        }
        /**
         * Setup page view tracking for SPAs
         */
        setupPageViewTracking() {
            // Track browser navigation (back/forward buttons)
            this.popstateListener = () => {
                const newPage = window.location.href;
                if (newPage !== this.currentPage) {
                    this.currentPage = newPage;
                    this.reachedScrollThresholds.clear();
                    this.trackPageView();
                }
            };
            window.addEventListener('popstate', this.popstateListener);
            // For SPAs that use pushState/replaceState
            const originalPushState = history.pushState;
            const originalReplaceState = history.replaceState;
            history.pushState = (...args) => {
                originalPushState.apply(history, args);
                setTimeout(() => {
                    const newPage = window.location.href;
                    if (newPage !== this.currentPage) {
                        this.currentPage = newPage;
                        this.reachedScrollThresholds.clear();
                        this.trackPageView();
                    }
                }, 0);
            };
            history.replaceState = (...args) => {
                originalReplaceState.apply(history, args);
                setTimeout(() => {
                    const newPage = window.location.href;
                    if (newPage !== this.currentPage) {
                        this.currentPage = newPage;
                        this.reachedScrollThresholds.clear();
                        this.trackPageView();
                    }
                }, 0);
            };
        }
        /**
         * Setup click tracking
         */
        setupClickTracking() {
            this.clickListener = (event) => {
                const target = event.target;
                if (!target || !target.tagName || CountlyUtils.shouldIgnoreElement(target, this.config.ignore_selectors)) {
                    return;
                }
                const elementInfo = this.getElementInfo(target);
                const eventData = {
                    key: 'element_click',
                    segmentation: {
                        element_tag: elementInfo.tag,
                        element_id: elementInfo.id || '',
                        element_classes: elementInfo.classes?.join(' ') || '',
                        element_text: elementInfo.text || '',
                        element_path: elementInfo.htmlPath || '',
                        parent_tag: elementInfo.parentTag || '',
                        parent_id: elementInfo.parentId || '',
                        parent_classes: elementInfo.parentClasses || '',
                        click_x: elementInfo.position?.x || 0,
                        click_y: elementInfo.position?.y || 0,
                        ...elementInfo.attributes
                    }
                };
                // Add special handling for links
                if (elementInfo.href) {
                    eventData.segmentation.link_url = elementInfo.href;
                    eventData.key = 'link_click';
                }
                this.eventQueue.addEvent(eventData);
                if (this.config.debug) {
                    console.log('Countly: Click tracked', elementInfo);
                }
            };
            document.addEventListener('click', this.clickListener, true);
        }
        /**
         * Setup form submission tracking
         */
        setupFormTracking() {
            this.submitListener = (event) => {
                const form = event.target;
                if (!form || form.tagName !== 'FORM' ||
                    CountlyUtils.shouldIgnoreElement(form, this.config.ignore_selectors)) {
                    return;
                }
                const formData = this.getFormData(form);
                const elementInfo = this.getElementInfo(form);
                const eventData = {
                    key: 'form_submit',
                    segmentation: {
                        element_id: elementInfo.id || '',
                        element_tag: elementInfo.tag,
                        element_path: elementInfo.htmlPath || '',
                        parent_tag: elementInfo.parentTag || '',
                        parent_id: elementInfo.parentId || '',
                        parent_classes: elementInfo.parentClasses || '',
                        form_id: form.id || elementInfo.id || '',
                        form_name: form.getAttribute('name') || '',
                        form_action: form.action || '',
                        form_method: form.method || 'get',
                        field_count: formData.fieldCount,
                        page_url: window.location.href,
                        ...formData.fields
                    }
                };
                this.eventQueue.addEvent(eventData);
                if (this.config.debug) {
                    console.log('Countly: Form submission tracked', formData);
                }
            };
            document.addEventListener('submit', this.submitListener, true);
        }
        /**
         * Setup scroll tracking
         */
        setupScrollTracking() {
            this.scrollListener = CountlyUtils.throttle(() => {
                const scrollInfo = this.getScrollInfo();
                // Check if we've reached a new threshold
                for (const threshold of this.scrollThresholds) {
                    if (scrollInfo.percentage >= threshold && !this.reachedScrollThresholds.has(threshold)) {
                        this.reachedScrollThresholds.add(threshold);
                        const eventData = {
                            key: 'scroll_depth',
                            segmentation: {
                                percentage: threshold,
                                depth_pixels: scrollInfo.depth,
                                page_height: scrollInfo.pageHeight,
                                viewport_height: scrollInfo.viewportHeight,
                                page_url: window.location.href
                            }
                        };
                        this.eventQueue.addEvent(eventData);
                        if (this.config.debug) {
                            console.log(`Countly: Scroll depth ${threshold}% tracked`);
                        }
                    }
                }
            }, 1000);
            window.addEventListener('scroll', this.scrollListener);
        }
        /**
         * Get element information for tracking
         */
        getElementInfo(element) {
            const classes = element.classList ? Array.from(element.classList) : [];
            const enhancedInfo = CountlyUtils.getElementInfo(element, this.config.capture_attributes);
            return {
                tag: element.tagName.toLowerCase(),
                id: enhancedInfo.element_id, // Use generated ID if none exists
                classes: classes.length > 0 ? classes : undefined,
                text: CountlyUtils.getElementText(element),
                attributes: enhancedInfo.attributes,
                position: CountlyUtils.getElementPosition(element),
                href: element.getAttribute('href') || undefined,
                htmlPath: enhancedInfo.element_path,
                parentTag: enhancedInfo.parent_tag,
                parentId: enhancedInfo.parent_id,
                parentClasses: enhancedInfo.parent_classes
            };
        }
        /**
         * Get form data for tracking
         */
        getFormData(form) {
            const fields = {};
            new FormData(form);
            let fieldCount = 0;
            // Get form field types and names (but not sensitive values)
            const inputs = form.querySelectorAll('input, select, textarea');
            inputs.forEach((input) => {
                const inputElement = input;
                const name = inputElement.name || inputElement.id || `field_${fieldCount}`;
                const type = inputElement.type || inputElement.tagName.toLowerCase();
                // Don't capture sensitive data
                if (!['password', 'hidden', 'file'].includes(type)) {
                    fields[`${name}_type`] = type;
                    fieldCount++;
                }
            });
            return { fieldCount, fields };
        }
        /**
         * Get current scroll information
         */
        getScrollInfo() {
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const windowHeight = window.innerHeight;
            const documentHeight = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);
            const scrollableHeight = documentHeight - windowHeight;
            const percentage = scrollableHeight > 0 ? Math.round((scrollTop / scrollableHeight) * 100) : 100;
            return {
                percentage: Math.min(percentage, 100),
                depth: scrollTop,
                pageHeight: documentHeight,
                viewportHeight: windowHeight
            };
        }
        /**
         * Setup focus/unfocus tracking
         */
        setupFocusTracking() {
            // Track focus events
            this.focusListener = (event) => {
                const target = event.target;
                if (!this.isTrackableInput(target) ||
                    CountlyUtils.shouldIgnoreElement(target, this.config.ignore_selectors)) {
                    return;
                }
                const focusTime = Date.now();
                this.focusStartTimes.set(target, focusTime);
                const inputInfo = this.getInputInfo(target);
                const eventData = {
                    key: 'input_focus',
                    segmentation: {
                        element_id: inputInfo.id || '',
                        element_path: inputInfo.element_path || '',
                        parent_tag: inputInfo.parent_tag || '',
                        parent_id: inputInfo.parent_id || '',
                        parent_classes: inputInfo.parent_classes || '',
                        input_type: inputInfo.type,
                        input_name: inputInfo.name || '',
                        input_placeholder: inputInfo.placeholder || '',
                        input_required: inputInfo.required,
                        form_id: inputInfo.form_id || '',
                        field_position: inputInfo.field_position || 0,
                        label_text: inputInfo.label_text || '',
                        label_id: inputInfo.label_id || '',
                        label_association: inputInfo.label_association || '',
                        page_url: window.location.href
                    }
                };
                this.eventQueue.addEvent(eventData);
                if (this.config.debug) {
                    console.log('Countly: Input focus tracked', inputInfo);
                }
            };
            // Track blur (unfocus) events
            this.blurListener = (event) => {
                const target = event.target;
                if (!this.isTrackableInput(target) ||
                    CountlyUtils.shouldIgnoreElement(target, this.config.ignore_selectors)) {
                    return;
                }
                const focusStartTime = this.focusStartTimes.get(target);
                const focusDuration = focusStartTime ? Date.now() - focusStartTime : 0;
                this.focusStartTimes.delete(target);
                const inputInfo = this.getInputInfo(target);
                const eventData = {
                    key: 'input_blur',
                    dur: Math.round(focusDuration / 1000), // Convert to seconds
                    segmentation: {
                        element_id: inputInfo.id || '',
                        element_path: inputInfo.element_path || '',
                        parent_tag: inputInfo.parent_tag || '',
                        parent_id: inputInfo.parent_id || '',
                        parent_classes: inputInfo.parent_classes || '',
                        input_type: inputInfo.type,
                        input_name: inputInfo.name || '',
                        input_placeholder: inputInfo.placeholder || '',
                        input_required: inputInfo.required,
                        form_id: inputInfo.form_id || '',
                        field_position: inputInfo.field_position || 0,
                        focus_duration_ms: focusDuration,
                        value_length: inputInfo.value_length,
                        label_text: inputInfo.label_text || '',
                        label_id: inputInfo.label_id || '',
                        label_association: inputInfo.label_association || '',
                        page_url: window.location.href
                    }
                };
                this.eventQueue.addEvent(eventData);
                if (this.config.debug) {
                    console.log('Countly: Input blur tracked', { ...inputInfo, focus_duration_ms: focusDuration });
                }
            };
            document.addEventListener('focusin', this.focusListener, true);
            document.addEventListener('focusout', this.blurListener, true);
        }
        /**
         * Setup input change tracking
         */
        setupInputTracking() {
            // Track input events (as user types)
            this.inputListener = CountlyUtils.debounce((event) => {
                const target = event.target;
                if (!this.isTrackableInput(target) ||
                    CountlyUtils.shouldIgnoreElement(target, this.config.ignore_selectors)) {
                    return;
                }
                const lastInteractionTime = this.inputInteractionTimes.get(target);
                const currentTime = Date.now();
                // Only track if it's been at least 2 seconds since last interaction with this field
                if (lastInteractionTime && (currentTime - lastInteractionTime) < 2000) {
                    return;
                }
                this.inputInteractionTimes.set(target, currentTime);
                const inputInfo = this.getInputInfo(target);
                const eventData = {
                    key: 'input_change',
                    segmentation: {
                        element_id: inputInfo.id || '',
                        element_path: inputInfo.element_path || '',
                        parent_tag: inputInfo.parent_tag || '',
                        parent_id: inputInfo.parent_id || '',
                        parent_classes: inputInfo.parent_classes || '',
                        input_type: inputInfo.type,
                        input_name: inputInfo.name || '',
                        input_placeholder: inputInfo.placeholder || '',
                        input_required: inputInfo.required,
                        form_id: inputInfo.form_id || '',
                        field_position: inputInfo.field_position || 0,
                        value_length: inputInfo.value_length,
                        interaction_type: 'typing',
                        label_text: inputInfo.label_text || '',
                        label_id: inputInfo.label_id || '',
                        label_association: inputInfo.label_association || '',
                        page_url: window.location.href
                    }
                };
                this.eventQueue.addEvent(eventData);
                if (this.config.debug) {
                    console.log('Countly: Input change tracked', inputInfo);
                }
            }, 1000);
            // Track change events (when user finishes with field)
            this.changeListener = (event) => {
                const target = event.target;
                if (!this.isTrackableInput(target) ||
                    CountlyUtils.shouldIgnoreElement(target, this.config.ignore_selectors)) {
                    return;
                }
                const inputInfo = this.getInputInfo(target);
                const eventData = {
                    key: 'input_change',
                    segmentation: {
                        element_id: inputInfo.id || '',
                        element_path: inputInfo.element_path || '',
                        parent_tag: inputInfo.parent_tag || '',
                        parent_id: inputInfo.parent_id || '',
                        parent_classes: inputInfo.parent_classes || '',
                        input_type: inputInfo.type,
                        input_name: inputInfo.name || '',
                        input_placeholder: inputInfo.placeholder || '',
                        input_required: inputInfo.required,
                        form_id: inputInfo.form_id || '',
                        field_position: inputInfo.field_position || 0,
                        value_length: inputInfo.value_length,
                        interaction_type: 'change',
                        label_text: inputInfo.label_text || '',
                        label_id: inputInfo.label_id || '',
                        label_association: inputInfo.label_association || '',
                        page_url: window.location.href
                    }
                };
                this.eventQueue.addEvent(eventData);
                if (this.config.debug) {
                    console.log('Countly: Input change event tracked', inputInfo);
                }
            };
            document.addEventListener('input', this.inputListener, true);
            document.addEventListener('change', this.changeListener, true);
        }
        /**
         * Check if element is a trackable input
         */
        isTrackableInput(element) {
            const tagName = element.tagName.toLowerCase();
            const inputType = element.type?.toLowerCase();
            // Track input, textarea, select elements
            if (['input', 'textarea', 'select'].includes(tagName)) {
                // Don't track sensitive input types
                if (tagName === 'input' && ['password', 'hidden', 'file'].includes(inputType)) {
                    return false;
                }
                return true;
            }
            // Track contenteditable elements
            if (element.getAttribute('contenteditable') === 'true') {
                return true;
            }
            return false;
        }
        /**
         * Get input field information
         */
        getInputInfo(input) {
            const form = input.closest('form');
            let fieldPosition = 0;
            if (form) {
                const inputElements = form.querySelectorAll('input, textarea, select');
                const formInputs = inputElements ? Array.from(inputElements) : [];
                fieldPosition = formInputs.indexOf(input) + 1;
            }
            // Get value length without exposing actual value for privacy
            let valueLength = 0;
            if (input.value && !['password', 'hidden'].includes(input.type)) {
                valueLength = input.value.length;
            }
            // Get enhanced element information
            const enhancedInfo = CountlyUtils.getElementInfo(input, this.config.capture_attributes);
            // Get associated label information
            const labelInfo = CountlyUtils.getInputLabel(input);
            return {
                type: input.type || input.tagName.toLowerCase(),
                name: input.name || undefined,
                id: enhancedInfo.element_id, // Use generated ID if none exists
                placeholder: input.placeholder || undefined,
                required: input.required,
                value_length: valueLength,
                form_id: form?.id || undefined,
                field_position: fieldPosition,
                element_path: enhancedInfo.element_path,
                parent_tag: enhancedInfo.parent_tag,
                parent_id: enhancedInfo.parent_id,
                parent_classes: enhancedInfo.parent_classes,
                label_text: labelInfo.text,
                label_id: labelInfo.id,
                label_association: labelInfo.association
            };
        }
        /**
         * Setup media event tracking (video/audio)
         */
        setupMediaTracking() {
            // Find all media elements and setup listeners
            const mediaElements = document.querySelectorAll('video, audio');
            mediaElements.forEach(element => {
                this.addMediaListeners(element);
            });
            // Use MutationObserver to track dynamically added media elements
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            const element = node;
                            if (element.tagName === 'VIDEO' || element.tagName === 'AUDIO') {
                                this.addMediaListeners(element);
                            }
                            // Check children too
                            const mediaChildren = element.querySelectorAll?.('video, audio');
                            mediaChildren?.forEach(child => this.addMediaListeners(child));
                        }
                    });
                });
            });
            observer.observe(document.body, { childList: true, subtree: true });
        }
        /**
         * Add media event listeners to an element
         */
        addMediaListeners(element) {
            if (this.mediaElements.has(element))
                return;
            this.mediaElements.add(element);
            const mediaElement = element;
            const mediaType = element.tagName.toLowerCase();
            const mediaId = element.id || element.getAttribute('data-video-id') || element.getAttribute('data-audio-id') || `${mediaType}_${Date.now()}`;
            const events = ['play', 'pause', 'ended', 'volumechange', 'seeking', 'loadstart', 'canplay', 'waiting'];
            events.forEach(eventName => {
                const listener = () => {
                    const eventData = {
                        key: `${mediaType}_${eventName}`,
                        segmentation: {
                            media_id: mediaId,
                            media_type: mediaType,
                            current_time: Math.round(mediaElement.currentTime || 0),
                            duration: Math.round(mediaElement.duration || 0),
                            volume: Math.round((mediaElement.volume || 0) * 100),
                            muted: mediaElement.muted,
                            page_url: window.location.href
                        }
                    };
                    this.eventQueue.addEvent(eventData);
                    if (this.config.debug) {
                        console.log(`Countly: ${mediaType} ${eventName} tracked`, eventData.segmentation);
                    }
                };
                mediaElement.addEventListener(eventName, listener);
            });
        }
        /**
         * Remove media event listeners from an element
         */
        removeMediaListeners(element) {
            // This is automatically handled by browser when element is removed
            // We just need to remove from our tracking set
        }
        /**
         * Setup mouse behavior tracking
         */
        setupMouseTracking() {
            // Mouse enter tracking (throttled)
            this.mouseenterListener = CountlyUtils.throttle((event) => {
                const target = event.target;
                if (!target || !target.tagName || CountlyUtils.shouldIgnoreElement(target, this.config.ignore_selectors)) {
                    return;
                }
                const hoverTime = Date.now();
                this.hoverStartTimes.set(target, hoverTime);
                const elementInfo = this.getElementInfo(target);
                const eventData = {
                    key: 'element_hover_start',
                    segmentation: {
                        element_id: elementInfo.id || '',
                        element_tag: elementInfo.tag,
                        element_classes: elementInfo.classes?.join(' ') || '',
                        element_path: elementInfo.htmlPath || '',
                        parent_tag: elementInfo.parentTag || '',
                        parent_id: elementInfo.parentId || '',
                        parent_classes: elementInfo.parentClasses || '',
                        page_url: window.location.href,
                        ...elementInfo.attributes
                    }
                };
                this.eventQueue.addEvent(eventData);
                if (this.config.debug) {
                    console.log('Countly: Hover start tracked', elementInfo);
                }
            }, 1000);
            // Mouse leave tracking
            this.mouseleaveListener = (event) => {
                const target = event.target;
                if (!target || !target.tagName || CountlyUtils.shouldIgnoreElement(target, this.config.ignore_selectors)) {
                    return;
                }
                const hoverStartTime = this.hoverStartTimes.get(target);
                const hoverDuration = hoverStartTime ? Date.now() - hoverStartTime : 0;
                this.hoverStartTimes.delete(target);
                if (hoverDuration > 500) { // Only track hovers longer than 500ms
                    const elementInfo = this.getElementInfo(target);
                    const eventData = {
                        key: 'element_hover_end',
                        dur: Math.round(hoverDuration / 1000),
                        segmentation: {
                            element_id: elementInfo.id || '',
                            element_tag: elementInfo.tag,
                            element_classes: elementInfo.classes?.join(' ') || '',
                            element_path: elementInfo.htmlPath || '',
                            parent_tag: elementInfo.parentTag || '',
                            parent_id: elementInfo.parentId || '',
                            parent_classes: elementInfo.parentClasses || '',
                            hover_duration_ms: hoverDuration,
                            page_url: window.location.href,
                            ...elementInfo.attributes
                        }
                    };
                    this.eventQueue.addEvent(eventData);
                    if (this.config.debug) {
                        console.log('Countly: Hover end tracked', { ...elementInfo, hover_duration_ms: hoverDuration });
                    }
                }
            };
            // Right-click tracking
            this.contextmenuListener = (event) => {
                const target = event.target;
                if (!target || !target.tagName || CountlyUtils.shouldIgnoreElement(target, this.config.ignore_selectors)) {
                    return;
                }
                const elementInfo = this.getElementInfo(target);
                const eventData = {
                    key: 'element_right_click',
                    segmentation: {
                        element_id: elementInfo.id || '',
                        element_tag: elementInfo.tag,
                        element_classes: elementInfo.classes?.join(' ') || '',
                        element_path: elementInfo.htmlPath || '',
                        parent_tag: elementInfo.parentTag || '',
                        parent_id: elementInfo.parentId || '',
                        parent_classes: elementInfo.parentClasses || '',
                        click_x: elementInfo.position?.x || 0,
                        click_y: elementInfo.position?.y || 0,
                        ...elementInfo.attributes
                    }
                };
                this.eventQueue.addEvent(eventData);
                if (this.config.debug) {
                    console.log('Countly: Right-click tracked', elementInfo);
                }
            };
            // Double-click tracking
            this.dblclickListener = (event) => {
                const target = event.target;
                if (!target || !target.tagName || CountlyUtils.shouldIgnoreElement(target, this.config.ignore_selectors)) {
                    return;
                }
                const elementInfo = this.getElementInfo(target);
                const eventData = {
                    key: 'element_double_click',
                    segmentation: {
                        element_id: elementInfo.id || '',
                        element_tag: elementInfo.tag,
                        element_classes: elementInfo.classes?.join(' ') || '',
                        element_path: elementInfo.htmlPath || '',
                        parent_tag: elementInfo.parentTag || '',
                        parent_id: elementInfo.parentId || '',
                        parent_classes: elementInfo.parentClasses || '',
                        click_x: elementInfo.position?.x || 0,
                        click_y: elementInfo.position?.y || 0,
                        ...elementInfo.attributes
                    }
                };
                this.eventQueue.addEvent(eventData);
                if (this.config.debug) {
                    console.log('Countly: Double-click tracked', elementInfo);
                }
            };
            document.addEventListener('mouseenter', this.mouseenterListener, true);
            document.addEventListener('mouseleave', this.mouseleaveListener, true);
            document.addEventListener('contextmenu', this.contextmenuListener, true);
            document.addEventListener('dblclick', this.dblclickListener, true);
        }
        /**
         * Setup keyboard event tracking
         */
        setupKeyboardTracking() {
            this.keydownListener = (event) => {
                const keyEvent = event;
                const target = keyEvent.target;
                // Track keyboard shortcuts
                if (keyEvent.ctrlKey || keyEvent.metaKey || keyEvent.altKey || ['Escape', 'F1', 'F2', 'F3', 'F4', 'F5'].includes(keyEvent.key)) {
                    const shortcut = [];
                    if (keyEvent.ctrlKey)
                        shortcut.push('ctrl');
                    if (keyEvent.metaKey)
                        shortcut.push('cmd');
                    if (keyEvent.altKey)
                        shortcut.push('alt');
                    if (keyEvent.shiftKey)
                        shortcut.push('shift');
                    shortcut.push(keyEvent.key.toLowerCase());
                    const eventData = {
                        key: 'keyboard_shortcut',
                        segmentation: {
                            shortcut: shortcut.join('+'),
                            element_tag: target?.tagName?.toLowerCase() || 'unknown',
                            element_id: target?.id || '',
                            page_url: window.location.href
                        }
                    };
                    this.eventQueue.addEvent(eventData);
                    if (this.config.debug) {
                        console.log('Countly: Keyboard shortcut tracked', eventData.segmentation);
                    }
                }
            };
            // Track copy/paste/cut events
            ['copy', 'paste', 'cut'].forEach(eventName => {
                document.addEventListener(eventName, (event) => {
                    const target = event.target;
                    const eventData = {
                        key: `keyboard_${eventName}`,
                        segmentation: {
                            element_tag: target?.tagName?.toLowerCase() || 'unknown',
                            element_id: target?.id || '',
                            page_url: window.location.href
                        }
                    };
                    this.eventQueue.addEvent(eventData);
                    if (this.config.debug) {
                        console.log(`Countly: ${eventName} tracked`, eventData.segmentation);
                    }
                });
            });
            document.addEventListener('keydown', this.keydownListener, true);
        }
        /**
         * Setup visibility change tracking
         */
        setupVisibilityTracking() {
            this.visibilityListener = () => {
                const isVisible = !document.hidden;
                const currentTime = Date.now();
                if (isVisible) {
                    this.visibilityStartTime = currentTime;
                    const eventData = {
                        key: 'tab_visible',
                        segmentation: {
                            total_hidden_time_ms: currentTime - this.visibilityStartTime,
                            page_url: window.location.href
                        }
                    };
                    this.eventQueue.addEvent(eventData);
                }
                else {
                    const timeSpent = currentTime - this.visibilityStartTime;
                    this.totalVisibleTime += timeSpent;
                    const eventData = {
                        key: 'tab_hidden',
                        dur: Math.round(timeSpent / 1000),
                        segmentation: {
                            time_visible_ms: timeSpent,
                            total_visible_time_ms: this.totalVisibleTime,
                            page_url: window.location.href
                        }
                    };
                    this.eventQueue.addEvent(eventData);
                }
                if (this.config.debug) {
                    console.log(`Countly: Tab ${isVisible ? 'visible' : 'hidden'} tracked`);
                }
            };
            // Track page unload
            this.beforeunloadListener = () => {
                const sessionDuration = Date.now() - this.visibilityStartTime;
                const eventData = {
                    key: 'page_unload',
                    dur: Math.round(sessionDuration / 1000),
                    segmentation: {
                        session_duration_ms: sessionDuration,
                        total_visible_time_ms: this.totalVisibleTime,
                        page_url: window.location.href
                    }
                };
                this.eventQueue.addEvent(eventData);
                this.eventQueue.flush(); // Force flush on unload
            };
            document.addEventListener('visibilitychange', this.visibilityListener);
            window.addEventListener('beforeunload', this.beforeunloadListener);
        }
        /**
         * Setup window and layout event tracking
         */
        setupWindowTracking() {
            // Window resize tracking (debounced)
            this.resizeListener = CountlyUtils.debounce(() => {
                const eventData = {
                    key: 'window_resize',
                    segmentation: {
                        window_width: window.innerWidth,
                        window_height: window.innerHeight,
                        screen_width: screen.width,
                        screen_height: screen.height,
                        device_pixel_ratio: window.devicePixelRatio || 1,
                        page_url: window.location.href
                    }
                };
                this.eventQueue.addEvent(eventData);
                if (this.config.debug) {
                    console.log('Countly: Window resize tracked', eventData.segmentation);
                }
            }, 1000);
            // Online/offline tracking
            this.onlineListener = () => {
                const eventData = {
                    key: 'connection_online',
                    segmentation: {
                        connection_effective_type: navigator.connection?.effectiveType || 'unknown',
                        page_url: window.location.href
                    }
                };
                this.eventQueue.addEvent(eventData);
                if (this.config.debug) {
                    console.log('Countly: Connection online tracked');
                }
            };
            this.offlineListener = () => {
                const eventData = {
                    key: 'connection_offline',
                    segmentation: {
                        page_url: window.location.href
                    }
                };
                this.eventQueue.addEvent(eventData);
                if (this.config.debug) {
                    console.log('Countly: Connection offline tracked');
                }
            };
            // Orientation change tracking
            this.orientationListener = () => {
                const eventData = {
                    key: 'orientation_change',
                    segmentation: {
                        orientation: screen.orientation?.type || 'unknown',
                        angle: screen.orientation?.angle || 0,
                        window_width: window.innerWidth,
                        window_height: window.innerHeight,
                        page_url: window.location.href
                    }
                };
                this.eventQueue.addEvent(eventData);
                if (this.config.debug) {
                    console.log('Countly: Orientation change tracked', eventData.segmentation);
                }
            };
            window.addEventListener('resize', this.resizeListener);
            window.addEventListener('online', this.onlineListener);
            window.addEventListener('offline', this.offlineListener);
            window.addEventListener('orientationchange', this.orientationListener);
        }
        /**
         * Setup text selection tracking
         */
        setupSelectionTracking() {
            this.selectionListener = CountlyUtils.debounce(() => {
                const selection = window.getSelection();
                if (selection && selection.toString().length > 0) {
                    const selectedText = selection.toString();
                    const range = selection.getRangeAt(0);
                    const container = range.commonAncestorContainer;
                    const element = container.nodeType === Node.TEXT_NODE ?
                        container.parentElement : container;
                    if (element) {
                        const elementInfo = this.getElementInfo(element);
                        const eventData = {
                            key: 'text_selection',
                            segmentation: {
                                element_id: elementInfo.id || '',
                                element_tag: elementInfo.tag,
                                element_classes: elementInfo.classes?.join(' ') || '',
                                element_path: elementInfo.htmlPath || '',
                                parent_tag: elementInfo.parentTag || '',
                                parent_id: elementInfo.parentId || '',
                                parent_classes: elementInfo.parentClasses || '',
                                selected_length: selectedText.length,
                                selected_text_preview: CountlyUtils.sanitizeString(selectedText.substring(0, 50)),
                                page_url: window.location.href
                            }
                        };
                        this.eventQueue.addEvent(eventData);
                        if (this.config.debug) {
                            console.log('Countly: Text selection tracked', eventData.segmentation);
                        }
                    }
                }
            }, 500);
            document.addEventListener('mouseup', this.selectionListener, true);
            document.addEventListener('keyup', this.selectionListener, true);
        }
        /**
         * Setup performance event tracking
         */
        setupPerformanceTracking() {
            // Track page load performance
            window.addEventListener('load', () => {
                if (performance.timing) {
                    const timing = performance.timing;
                    const navigation = timing.loadEventEnd - timing.navigationStart;
                    const domReady = timing.domContentLoadedEventEnd - timing.navigationStart;
                    const pageLoad = timing.loadEventEnd - timing.loadEventStart;
                    const dnsLookup = timing.domainLookupEnd - timing.domainLookupStart;
                    const tcpConnect = timing.connectEnd - timing.connectStart;
                    const serverResponse = timing.responseEnd - timing.requestStart;
                    const eventData = {
                        key: 'page_performance',
                        dur: Math.round(navigation / 1000),
                        segmentation: {
                            navigation_time: navigation,
                            dom_ready_time: domReady,
                            page_load_time: pageLoad,
                            dns_lookup_time: dnsLookup,
                            tcp_connect_time: tcpConnect,
                            server_response_time: serverResponse,
                            page_url: window.location.href
                        }
                    };
                    this.eventQueue.addEvent(eventData);
                    if (this.config.debug) {
                        console.log('Countly: Page performance tracked', eventData.segmentation);
                    }
                }
            });
            // Track resource loading errors
            window.addEventListener('error', (event) => {
                if (event.target !== window) {
                    const element = event.target;
                    const eventData = {
                        key: 'resource_error',
                        segmentation: {
                            resource_type: element.tagName?.toLowerCase() || 'unknown',
                            resource_src: element.getAttribute('src') || element.getAttribute('href') || '',
                            page_url: window.location.href
                        }
                    };
                    this.eventQueue.addEvent(eventData);
                    if (this.config.debug) {
                        console.log('Countly: Resource error tracked', eventData.segmentation);
                    }
                }
            }, true);
        }
    }

    /**
     * Main Countly Web Tracker SDK
     */
    class CountlyTracker {
        constructor() {
            this.isInitialized = false;
            this.sessionId = CountlyUtils.generateDeviceId();
            this.sessionStartTime = Date.now();
            // Default configuration
            this.config = {
                url: '',
                app_key: '',
                device_id: '',
                app_version: '',
                debug: false,
                auto_track_views: true,
                auto_track_clicks: true,
                auto_track_forms: true,
                auto_track_scroll: true,
                auto_track_focus: true,
                auto_track_inputs: true,
                auto_track_media: true,
                auto_track_mouse: true,
                auto_track_keyboard: true,
                auto_track_visibility: true,
                auto_track_window: true,
                auto_track_selection: true,
                auto_track_performance: true,
                session_duration: 30 * 60 * 1000, // 30 minutes
                ignore_selectors: [
                    '[data-countly-ignore]',
                    '.countly-ignore',
                    'script',
                    'style',
                    'noscript'
                ],
                capture_attributes: [
                    'data-*',
                    'aria-label',
                    'alt',
                    'title'
                ]
            };
            this.eventQueue = new EventQueue({
                url: '',
                app_key: '',
                device_id: '',
                app_version: '',
                debug: false
            });
            this.autoTracker = new AutoTracker(this.eventQueue, this.config);
        }
        /**
         * Initialize the tracker with configuration
         */
        init(config) {
            // Merge with defaults
            this.config = {
                ...this.config,
                ...config,
                device_id: config.device_id || CountlyUtils.getDeviceId()
            };
            // Validate required config
            if (!this.config.url) {
                throw new Error('Countly: URL is required');
            }
            if (!this.config.app_key) {
                throw new Error('Countly: App key is required');
            }
            // Initialize event queue with config
            this.eventQueue = new EventQueue({
                url: this.config.url,
                app_key: this.config.app_key,
                device_id: this.config.device_id,
                app_version: this.config.app_version || '',
                debug: this.config.debug
            });
            // Initialize auto tracker
            this.autoTracker = new AutoTracker(this.eventQueue, this.config);
            // Setup unload listeners
            this.eventQueue.setupUnloadListener();
            this.isInitialized = true;
            if (this.config.debug) {
                console.log('Countly: Initialized with config', this.config);
            }
            return this;
        }
        /**
         * Start automatic tracking
         */
        start() {
            if (!this.isInitialized) {
                throw new Error('Countly: Must call init() before start()');
            }
            this.autoTracker.start();
            this.trackSession('session_start');
            if (this.config.debug) {
                console.log('Countly: Automatic tracking started');
            }
            return this;
        }
        /**
         * Stop automatic tracking
         */
        stop() {
            this.autoTracker.stop();
            this.trackSession('session_end');
            this.eventQueue.stopAutoFlush();
            if (this.config.debug) {
                console.log('Countly: Tracking stopped');
            }
            return this;
        }
        /**
         * Track a custom event
         */
        track(key, segmentation, count, sum) {
            if (!this.isInitialized) {
                throw new Error('Countly: Must call init() before tracking events');
            }
            const event = {
                key: CountlyUtils.sanitizeString(key),
                count: count || 1,
                segmentation: segmentation || {},
                sum: sum
            };
            this.eventQueue.addEvent(event);
            if (this.config.debug) {
                console.log('Countly: Custom event tracked', event);
            }
            return this;
        }
        /**
         * Track a page view manually
         */
        trackPageView(url, title) {
            const pageInfo = CountlyUtils.getCurrentPage();
            const event = {
                key: 'page_view',
                segmentation: {
                    url: url || pageInfo.url,
                    title: title || pageInfo.title,
                    referrer: pageInfo.referrer || ''
                }
            };
            this.eventQueue.addEvent(event);
            if (this.config.debug) {
                console.log('Countly: Manual page view tracked', event);
            }
            return this;
        }
        /**
         * Track user timing (e.g., load times, API response times)
         */
        trackTiming(category, variable, time, label) {
            const event = {
                key: 'user_timing',
                dur: Math.round(time / 1000), // Convert to seconds
                segmentation: {
                    category: CountlyUtils.sanitizeString(category),
                    variable: CountlyUtils.sanitizeString(variable),
                    label: label ? CountlyUtils.sanitizeString(label) : ''
                }
            };
            this.eventQueue.addEvent(event);
            if (this.config.debug) {
                console.log('Countly: Timing tracked', event);
            }
            return this;
        }
        /**
         * Track an error or exception
         */
        trackError(error, fatal = false) {
            const errorMessage = error instanceof Error ? error.message : error;
            const stack = error instanceof Error ? error.stack : '';
            const event = {
                key: 'javascript_error',
                segmentation: {
                    error: CountlyUtils.sanitizeString(errorMessage),
                    stack: stack ? CountlyUtils.sanitizeString(stack) : '',
                    fatal: fatal,
                    url: window.location.href,
                    user_agent: navigator.userAgent
                }
            };
            this.eventQueue.addEvent(event);
            if (this.config.debug) {
                console.log('Countly: Error tracked', event);
            }
            return this;
        }
        /**
         * Track session events
         */
        trackSession(type) {
            const duration = type === 'session_end' ?
                Math.round((Date.now() - this.sessionStartTime) / 1000) : 0;
            const event = {
                key: type,
                dur: duration,
                segmentation: {
                    session_id: this.sessionId,
                    url: window.location.href,
                    user_agent: navigator.userAgent,
                    screen_resolution: `${screen.width}x${screen.height}`,
                    viewport_size: `${window.innerWidth}x${window.innerHeight}`
                }
            };
            this.eventQueue.addEvent(event);
        }
        /**
         * Manually flush events to server
         */
        async flush() {
            await this.eventQueue.flush();
            return;
        }
        /**
         * Get current queue size
         */
        getQueueSize() {
            return this.eventQueue.getQueueSize();
        }
        /**
         * Clear all queued events
         */
        clearQueue() {
            this.eventQueue.clear();
            return this;
        }
        /**
         * Get current configuration
         */
        getConfig() {
            return { ...this.config };
        }
        /**
         * Check if tracker is initialized
         */
        isReady() {
            return this.isInitialized;
        }
        /**
         * Enable or disable debug mode
         */
        setDebug(enabled) {
            this.config.debug = enabled;
            return this;
        }
        /**
         * Add global error tracking
         */
        enableErrorTracking() {
            window.addEventListener('error', (event) => {
                this.trackError(event.error || event.message, true);
            });
            window.addEventListener('unhandledrejection', (event) => {
                this.trackError(event.reason, true);
            });
            return this;
        }
        /**
         * Track performance metrics
         */
        trackPerformance() {
            if (performance.timing) {
                const timing = performance.timing;
                const navigation = timing.loadEventEnd - timing.navigationStart;
                const domReady = timing.domContentLoadedEventEnd - timing.navigationStart;
                const pageLoad = timing.loadEventEnd - timing.loadEventStart;
                this.trackTiming('navigation', 'total', navigation);
                this.trackTiming('navigation', 'dom_ready', domReady);
                this.trackTiming('navigation', 'page_load', pageLoad);
            }
            return this;
        }
    }

    // Export main classes
    // Create default instance for easy usage
    const countly = new CountlyTracker();
    // Global installation function for browser usage
    if (typeof window !== 'undefined') {
        window.CountlyTracker = CountlyTracker;
        window.countly = countly;
    }

    exports.AutoTracker = AutoTracker;
    exports.CountlyTracker = CountlyTracker;
    exports.CountlyUtils = CountlyUtils;
    exports.EventQueue = EventQueue;
    exports.countly = countly;
    exports.default = CountlyTracker;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
